#!/usr/bin/python3

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from PIL import Image
import io
import sys
import getopt

# Reads a report from a user-specified file, filters the important 
# data and returns it in the form of a pandas data frame.
def parseReport(reportFile):

    f = open(reportFile)
    parsedContents = ""
    for line in f:
        if "Attenuation" in line:

            # Do some cleanup on the line contents:
            # 1. Remove the leading tab (or spaces)
            # 2. Remove the dB unit
            # 3. Remove useless strings
            # 3. Remove commas of the coordinates.
            line = line.lstrip("\t ").replace(" dB", "").replace(")-> Attenuation = ", "").replace("-> Target(", "").replace(", ", " ")
            parsedContents += line

    # Create a data frame from the parsed contents
    df = pd.read_csv(io.StringIO(parsedContents), sep=" ", header=None)

    # Do some more cleanup:
    # 1. Create a new first column concatenating the AP information
    df[0] = df[0] + "," + df[1]
    # 2. Remove the second column which now contains repeated information w.r.t. the first.
    df = df.drop(columns=[1])
    # 3. Relabel the columns
    df.columns = [0, 1, 2, 3]

    # One final issues is that, on some systems, the report file uses comma as a decimal separator (while
    # python expects dots). If values were not corrected interpreted as numbers, do the proper conversion.
    df[3] = df[3].str.replace(',', '.').astype(float)

    return df

# Parse cmdline arguments
def usage(args):

    print(
'''Use: python {} [--vmax MaxAttValue] [--vmin MinAttValue] [-p <ground_plan_img>] -r <WiFiCoverage_Report>

Description:

This tool generates coverage heatmaps based on the reports generated by WiFiCoverage. The heat maps can be 
(optionally) superimposed on top of a ground plan image (or any other desired image, for that matter).


The output is a series of PNG files generated in the current directory. One PNG is generated for each AP 
found on the report. Additionally, one last PNG is generated with the overall coverage, i.e., the coverage 
considering all APs combined. The names of the output file follow the convention "heatmap_AP(X,Y).png", 
where X and Y are the coordinates of the AP. The overall coverage heatmap is named "heatmap_overall.png"

Notice that this program *will replace any PNG with the same name as one of the generated ones without
any warning*.

Options:

    --vmax MaxAttValue
    --vmin MinAttValue:         specify the minimum and maximum attenuation values (in dBm) used for 
                                defining the range of colors of the heatmap. Those are optional. If 
                                not provided, the minimum and maximum values found on the report are 
                                used instead.

    -p <ground_plan_img>        specifies the path to the image to be used as the ground plan / background
                                of the heatmap. The ground plan image can be in any format supported by 
                                PIL. This tool assumes that the image has no margins, i.e., that its (0,0) 
                                pixel is aligned with the (0,0) coordinates of the report generated by 
                                WiFiCoverage. This is optional. If not provided, the heatmap will be 
                                plotted over a blank background.

    -r <WiFiCoverage_Report>    speficies the path of the report file generated by WiFiCoverage.

    -h, --help                  prints this help and exits
'''.format(args[0]))


try:
    opts, args = getopt.getopt(sys.argv[1:], 'p:r:h', ['vmax', 'vmin', 'help'])
except getopt.GetoptError as err:
    # print help information and exit:
    print("Error: ", end="")  # will print something like "option -a not recognized"
    print(err)  # will print something like "option -a not recognized"
    usage(sys.argv)
    sys.exit(2)

vmax = None
vmin = None
groundPlanFile = None
reportFile = None
for o, a in opts:
    if o == "-p":
        groundPlanFile = a
    elif o == "-r":
        reportFile = a
    elif o in ("-h", "--help"):
        usage(sys.argv)
        sys.exit()
    elif o == "--vmax":
        vmax = a
    elif o == "--vmin":
        vmin = a
    else:
        assert False, "unhandled option"

if reportFile == None:
    print("Error: The report file must be specified.")
    usage(sys.argv)
    sys.exit(2)

# Load the image of the ground floor for the background of the plots, if one was specified
if groundPlanFile is not None:
    plant = Image.open(groundPlanFile)
else:
    plant = None

# Load the results of the report
df = parseReport(reportFile)

if vmax == None:
    pwrMax = np.max(200-df[3] + 1)
else:
    pwrMax = 200-vmax+1

vmax = np.log(pwrMax)

if vmin == None:
    pwrMin = np.min(200-df[3] + 1)
else:
    pwrMin = 200-vmin+1
    
vmin = np.log(pwrMin)

#vmax=5.250176991220101
#vmin=4.1021473742851216

# Get list of APs
APs = np.unique(df[0])

# Create an array to hold the aggregated signal
aggregated = None 

for ap in APs:

    print("Processing the next AP: " + ap)

    # Set figure size
    plt.figure(figsize=(5,5))

    # Isolate the data for this AP
    apData = df.loc[df[0] == ap]

    # Find out the length of the y axis
    ylim = apData[apData[1] == 0][1].size

    # Reshape AP data into a matrix of ylim rows. Also, flip the 
    # sign of the data values, because lower attenuation is better.
    data = np.reshape(-np.array(apData[3]), (-1, ylim)).transpose()

    # Remove the axis of the plot
    plt.axis('off')

    # Now put the background image into the plot, if there is one
    if plant != None:
        plt.imshow(plant, extent=(0, data.shape[1], 0, data.shape[0]), origin='lower')

    # Finally, plot the data. We use a log function in order to make the
    # transition of the colors more pronounced.
    plt.imshow(np.log(200+data + 1), cmap='turbo', interpolation='lanczos', alpha=0.5, vmin=vmin, vmax=vmax)

    # Make sure the margins are not significant
    plt.tight_layout()

    # Show the result of the plot
    plt.savefig("heatmap_" + ap + ".png", format='png', dpi=300)
    plt.close()

    # Aggregate the data
    if aggregated is None:
        aggregated = data
    else:
        for i in range(0, data.shape[0]):
            for j in range(0, data.shape[1]):
                if (data[i][j] > aggregated[i][j]):
                    aggregated[i][j] = data[i][j]

# Plot the final, aggregated data
# Set figure size
plt.figure(figsize=(5,5))

# Remove the axis of the plot
plt.axis('off')


# Now put the background image into the plot, if there is one
if plant != None:
    plt.imshow(plant, extent=(0, data.shape[1], 0, data.shape[0]), origin='lower')

# Finally, plot the data. We use a log function in order to make the
# transition of the colors more pronounced.
plt.imshow(np.log(200+aggregated + 1), cmap='turbo', interpolation='lanczos', alpha=0.5, vmin=vmin, vmax=vmax)

# Make sure the margins are not significant
plt.tight_layout()

# Show the result of the plot
plt.savefig("heatmap_overall.png", format='png', dpi=300)
plt.close()


